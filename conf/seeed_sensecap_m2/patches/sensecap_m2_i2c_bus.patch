Index: openwrt/target/linux/ramips/mt76x8/config-6.6
===================================================================
--- openwrt.orig/target/linux/ramips/mt76x8/config-6.6
+++ openwrt/target/linux/ramips/mt76x8/config-6.6
@@ -86,7 +86,15 @@ CONFIG_HAS_DMA=y
 CONFIG_HAS_IOMEM=y
 CONFIG_HAS_IOPORT=y
 CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HWMON=y
 CONFIG_HZ_PERIODIC=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MT7621=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_GPIO=y
+# CONFIG_I2C_RALINK is not set
 CONFIG_ICPLUS_PHY=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_IRQCHIP=y
@@ -95,6 +103,18 @@ CONFIG_IRQ_FORCED_THREADING=y
 CONFIG_IRQ_INTC=y
 CONFIG_IRQ_MIPS_CPU=y
 CONFIG_IRQ_WORK=y
+# CONFIG_LEDS_AAT1290 is not set
+# CONFIG_LEDS_AS3645A is not set
+CONFIG_LEDS_AW2013=y
+CONFIG_LEDS_CLASS_FLASH=y
+CONFIG_LEDS_GROUP_MULTICOLOR=y
+# CONFIG_LEDS_KTD2692 is not set
+# CONFIG_LEDS_LM3601X is not set
+# CONFIG_LEDS_RT4505 is not set
+# CONFIG_LEDS_RT8515 is not set
+# CONFIG_LEDS_SGM3140 is not set
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_PATTERN=y
 CONFIG_LIBFDT=y
 CONFIG_LOCK_DEBUGGING_SUPPORT=y
 CONFIG_MDIO_BUS=y
@@ -175,6 +195,7 @@ CONFIG_RALINK=y
 CONFIG_RANDSTRUCT_NONE=y
 CONFIG_RATIONAL=y
 CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
 CONFIG_REGMAP_MMIO=y
 CONFIG_REGULATOR=y
 CONFIG_REGULATOR_FIXED_VOLTAGE=y
@@ -182,6 +203,7 @@ CONFIG_RESET_CONTROLLER=y
 CONFIG_RTC_CLASS=y
 CONFIG_RTC_I2C_AND_SPI=y
 CONFIG_RTC_MC146818_LIB=y
+CONFIG_SENSORS_STTS751=y
 CONFIG_SERIAL_8250_NR_UARTS=3
 CONFIG_SERIAL_8250_RUNTIME_UARTS=3
 CONFIG_SERIAL_MCTRL_GPIO=y
Index: openwrt/target/linux/ramips/dts/mt7628an_sensecap_wm7628n.dts
===================================================================
--- openwrt.orig/target/linux/ramips/dts/mt7628an_sensecap_wm7628n.dts
+++ openwrt/target/linux/ramips/dts/mt7628an_sensecap_wm7628n.dts
@@ -4,6 +4,7 @@
 
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
 
 / {
 	compatible = "sensecap,wm7628n", "mediatek,mt7628an-soc";
@@ -23,17 +24,17 @@
 		compatible = "gpio-leds";
 
 		wlan {
-			label = "green:wlan";
+			label = "blue:wlan";
 			gpios = <&gpio 44 GPIO_ACTIVE_LOW>;
 		};
 
 		wan {
-			label = "green:wan";
+			label = "amber:wan";
 			gpios = <&gpio 42 GPIO_ACTIVE_LOW>;
 		};
 
 		lora {
-			label = "green:lora";
+			label = "blue:lora";
 			gpios = <&gpio 36 GPIO_ACTIVE_LOW>;
 		};
 	};
@@ -56,6 +57,57 @@
 
 &i2c {
 	status = "okay";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	thermometer@39 {
+		/* The temperature sensor is manually read by concentratord
+		 * instead of being exposed through hwmon.
+		 */
+		reg = <0x39>;
+		compatible = "st,stts751";
+		status = "disabled";
+	};
+
+	crypto@60 {
+		/* Informational only; not currently supported. May be 508a
+		 * or 608a.
+		 */
+		reg = <0x60>;
+		compatible = "microchip,atecc508a";
+		status = "disabled";
+	};
+
+	led-controller@45 {
+		compatible = "awinic,aw2013";
+		status = "okay";
+		reg = <0x45>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		led@0 {
+			reg = <0>;
+			color = <LED_COLOR_ID_RED>;
+			function = "pattern";
+			led-max-microamp = <15000>;
+		};
+
+		led@1 {
+			reg = <1>;
+			color = <LED_COLOR_ID_GREEN>;
+			function = "pattern";
+			led-max-microamp = <15000>;
+		};
+
+		led@2 {
+			reg = <2>;
+			color = <LED_COLOR_ID_BLUE>;
+			function = "pattern";
+			led-max-microamp = <15000>;
+		};
+	};
 };
 
 &pinctrl {
Index: openwrt/target/linux/generic/hack-6.6/940-leds-aw2013-adjust-for-aw-2023.patch
===================================================================
--- /dev/null
+++ openwrt/target/linux/generic/hack-6.6/940-leds-aw2013-adjust-for-aw-2023.patch
@@ -0,0 +1,119 @@
+Index: linux-6.6.93/drivers/leds/leds-aw2013.c
+===================================================================
+--- linux-6.6.93.orig/drivers/leds/leds-aw2013.c
++++ linux-6.6.93/drivers/leds/leds-aw2013.c
+@@ -15,10 +15,14 @@
+ #define AW2013_RSTR 0x00
+ #define AW2013_RSTR_RESET 0x55
+ #define AW2013_RSTR_CHIP_ID 0x33
++#define AW2023_RSTR_CHIP_ID 0x09
+ 
+-/* Global control register */
+-#define AW2013_GCR 0x01
+-#define AW2013_GCR_ENABLE BIT(0)
++/* Global control registers */
++#define AW2013_GCR_1 0x01
++#define AW2013_GCR_1_ENABLE BIT(0)
++
++#define AW2023_GCR_2 0x04
++#define AW2023_GCR_2_CHIP_IMAX_MASK (BIT(0) | BIT(1) | BIT(2))
+ 
+ /* LED channel enable register */
+ #define AW2013_LCTR 0x30
+@@ -26,7 +30,7 @@
+ 
+ /* LED channel control registers */
+ #define AW2013_LCFG(x) (0x31 + (x))
+-#define AW2013_LCFG_IMAX_MASK (BIT(0) | BIT(1)) // Should be 0-3
++#define AW2013_LCFG_CUR_MASK (BIT(0) | BIT(1) | BIT(2) | BIT(3)) // Should be 0-15
+ #define AW2013_LCFG_MD BIT(4)
+ #define AW2013_LCFG_FI BIT(5)
+ #define AW2013_LCFG_FO BIT(6)
+@@ -67,6 +71,7 @@ struct aw2013 {
+ 	struct aw2013_led leds[AW2013_MAX_LEDS];
+ 	struct regmap *regmap;
+ 	int num_leds;
++	u8 chip_id;
+ 	bool enabled;
+ };
+ 
+@@ -74,7 +79,7 @@ static int aw2013_chip_init(struct aw201
+ {
+ 	int i, ret;
+ 
+-	ret = regmap_write(chip->regmap, AW2013_GCR, AW2013_GCR_ENABLE);
++	ret = regmap_write(chip->regmap, AW2013_GCR_1, AW2013_GCR_1_ENABLE);
+ 	if (ret) {
+ 		dev_err(&chip->client->dev, "Failed to enable the chip: %d\n",
+ 			ret);
+@@ -84,7 +89,7 @@ static int aw2013_chip_init(struct aw201
+ 	for (i = 0; i < chip->num_leds; i++) {
+ 		ret = regmap_update_bits(chip->regmap,
+ 					 AW2013_LCFG(chip->leds[i].num),
+-					 AW2013_LCFG_IMAX_MASK,
++					 AW2013_LCFG_CUR_MASK,
+ 					 chip->leds[i].imax);
+ 		if (ret) {
+ 			dev_err(&chip->client->dev,
+@@ -104,7 +109,7 @@ static void aw2013_chip_disable(struct a
+ 	if (!chip->enabled)
+ 		return;
+ 
+-	regmap_write(chip->regmap, AW2013_GCR, 0);
++	regmap_write(chip->regmap, AW2013_GCR_1, 0);
+ 
+ 	ret = regulator_bulk_disable(ARRAY_SIZE(chip->regulators),
+ 				     chip->regulators);
+@@ -292,9 +297,17 @@ static int aw2013_probe_dt(struct aw2013
+ 		init_data.fwnode = of_fwnode_handle(child);
+ 
+ 		if (!of_property_read_u32(child, "led-max-microamp", &imax)) {
+-			led->imax = min_t(u32, imax / 5000, 3);
++			if (chip->chip_id == AW2023_RSTR_CHIP_ID) {
++				led->imax = min_t(u32, imax / 1000, 15);
++			} else {
++				led->imax = min_t(u32, imax / 5000, 3);
++			}
+ 		} else {
+-			led->imax = 1; // 5mA
++			if (chip->chip_id == AW2023_RSTR_CHIP_ID) {
++				led->imax = 5; // 5mA
++			} else {
++				led->imax = 1; // 5mA
++			}
+ 			dev_info(&chip->client->dev,
+ 				 "DT property led-max-microamp is missing\n");
+ 		}
+@@ -377,13 +390,15 @@ static int aw2013_probe(struct i2c_clien
+ 		goto error_reg;
+ 	}
+ 
+-	if (chipid != AW2013_RSTR_CHIP_ID) {
+-		dev_err(&client->dev, "Chip reported wrong ID: %x\n",
++	if (chipid != AW2013_RSTR_CHIP_ID && chipid != AW2023_RSTR_CHIP_ID) {
++		dev_err(&client->dev, "Chip reported unknown ID: %x\n",
+ 			chipid);
+ 		ret = -ENODEV;
+ 		goto error_reg;
+ 	}
+ 
++	chip->chip_id = (uint8_t)chipid;
++
+ 	ret = aw2013_probe_dt(chip);
+ 	if (ret < 0)
+ 		goto error_reg;
+@@ -421,6 +436,7 @@ static void aw2013_remove(struct i2c_cli
+ 
+ static const struct of_device_id aw2013_match_table[] = {
+ 	{ .compatible = "awinic,aw2013", },
++	{ .compatible = "awinic,aw2023", },
+ 	{ /* sentinel */ },
+ };
+ 
+@@ -438,5 +454,5 @@ static struct i2c_driver aw2013_driver =
+ module_i2c_driver(aw2013_driver);
+ 
+ MODULE_AUTHOR("Nikita Travkin <nikitos.tr@gmail.com>");
+-MODULE_DESCRIPTION("AW2013 LED driver");
++MODULE_DESCRIPTION("AW20x3 LED driver");
+ MODULE_LICENSE("GPL v2");
Index: openwrt/target/linux/generic/hack-6.6/941-leds-aw2013-add-pattern.patch
===================================================================
--- /dev/null
+++ openwrt/target/linux/generic/hack-6.6/941-leds-aw2013-add-pattern.patch
@@ -0,0 +1,121 @@
+Index: linux-6.6.93/drivers/leds/leds-aw2013.c
+===================================================================
+--- linux-6.6.93.orig/drivers/leds/leds-aw2013.c
++++ linux-6.6.93/drivers/leds/leds-aw2013.c
+@@ -42,10 +42,12 @@
+ #define AW2013_LEDT0(x) (0x37 + (x) * 3)
+ #define AW2013_LEDT0_T1(x) ((x) << 4) // Should be 0-7
+ #define AW2013_LEDT0_T2(x) (x) // Should be 0-5
++#define AW2013_LEDT0_T1_T2(x, y) (AW2013_LEDT0_T1(x) | AW2013_LEDT0_T2(y))
+ 
+ #define AW2013_LEDT1(x) (0x38 + (x) * 3)
+ #define AW2013_LEDT1_T3(x) ((x) << 4) // Should be 0-7
+ #define AW2013_LEDT1_T4(x) (x) // Should be 0-7
++#define AW2013_LEDT1_T3_T4(x, y) (AW2013_LEDT1_T3(x) | AW2013_LEDT1_T4(y))
+ 
+ #define AW2013_LEDT2(x) (0x39 + (x) * 3)
+ #define AW2013_LEDT2_T0(x) ((x) << 4) // Should be 0-8
+@@ -199,6 +201,94 @@ error:
+ 	return ret;
+ }
+ 
++static int _aw2013_pattern_set(struct aw2013_led *led, unsigned int t[4])
++{
++	int ret;
++	u8 ticks[4];
++
++	for (int i=0; i < 4; i++)
++	{
++		/*
++		 * Convert into values the HW will understand. These are not actually
++		 * ticks, but a somewhat arbitrary mapping of values to time intervals.
++		 */
++		ticks[i] = min(15, ilog2((t[i] - 1) / AW2013_TIME_STEP) + 1);
++	}
++
++	ret = regmap_write(led->chip->regmap,
++			   AW2013_LEDT0(led->num), AW2013_LEDT0_T1_T2(ticks[0], ticks[1]));
++	if (ret)
++		return ret;
++	ret = regmap_write(led->chip->regmap,
++			   AW2013_LEDT1(led->num), AW2013_LEDT1_T3_T4(ticks[2], ticks[3]));
++
++	return ret;
++}
++
++static int aw2013_pattern_set(struct led_classdev *cdev,
++			   struct led_pattern *pattern, u32 len, int repeat)
++{
++	struct aw2013_led *led = container_of(cdev, struct aw2013_led, cdev);
++	int ret;
++	unsigned int t[4] = {0};
++
++	if (len == 2)
++	{
++		/* See leds-trigger-pattern.txt. We assume a smooth ramp. */
++		if (pattern[0].brightness != 0 || pattern[1].brightness != 255)
++			return -EINVAL;
++		t[0] = pattern[0].delta_t;
++		t[2] = pattern[1].delta_t;
++	}
++	else if (len == 4)
++	{
++		/* Specify all 4 intervals. */
++		if (pattern[0].brightness != 0 || pattern[1].brightness != 0 ||
++			pattern[2].brightness != 255 || pattern[3].brightness != 255)
++			return -EINVAL;
++		t[0] = pattern[0].delta_t;
++		t[1] = pattern[1].delta_t;
++		t[2] = pattern[2].delta_t;
++		t[3] = pattern[3].delta_t;
++	}
++	else
++	{
++		return -EINVAL;
++	}
++
++	mutex_lock(&led->chip->mutex);
++
++	ret = _aw2013_pattern_set(led, &t[0]);
++	if (ret)
++		goto error;
++
++	/* Set to pattern mode */
++	ret = regmap_update_bits(led->chip->regmap, AW2013_LCFG(led->num),
++				AW2013_LCFG_MD, 0xFF);
++
++error:
++	mutex_unlock(&led->chip->mutex);
++
++	return ret;
++
++}
++
++static int aw2013_pattern_clear(struct led_classdev *cdev)
++{
++	struct aw2013_led *led = container_of(cdev, struct aw2013_led, cdev);
++	int ret;
++
++	mutex_lock(&led->chip->mutex);
++
++	/* Set to manual mode */
++	ret = regmap_update_bits(led->chip->regmap, AW2013_LCFG(led->num),
++				AW2013_LCFG_MD, 0);
++
++	mutex_unlock(&led->chip->mutex);
++
++	return ret;
++}
++
+ static int aw2013_blink_set(struct led_classdev *cdev,
+ 			    unsigned long *delay_on, unsigned long *delay_off)
+ {
+@@ -314,6 +404,8 @@ static int aw2013_probe_dt(struct aw2013
+ 
+ 		led->cdev.brightness_set_blocking = aw2013_brightness_set;
+ 		led->cdev.blink_set = aw2013_blink_set;
++		led->cdev.pattern_set = aw2013_pattern_set;
++		led->cdev.pattern_clear = aw2013_pattern_clear;
+ 
+ 		ret = devm_led_classdev_register_ext(&chip->client->dev,
+ 						     &led->cdev, &init_data);
